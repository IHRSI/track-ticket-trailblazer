
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import { toast } from 'sonner';
import type { Database } from './types';

const SUPABASE_URL = "https://glyuihwsarbihppjqeti.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdseXVpaHdzYXJiaWhwcGpxZXRpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDM2MTA2NzIsImV4cCI6MjA1OTE4NjY3Mn0.NlHh9_z2qdDqzwAd-OYLL48_b7e_8gwXCxx0ghBPtj8";

// Create an event emitter for query logging
export const queryLogEvents = {
  listeners: new Set<(query: {sql: string, operation: string, timestamp: string}) => void>(),
  
  // Add a listener to get notified of queries
  addListener(callback: (query: {sql: string, operation: string, timestamp: string}) => void) {
    this.listeners.add(callback);
    return () => this.listeners.delete(callback);
  },
  
  // Emit a query event to all listeners
  emitQuery(query: {sql: string, operation: string, timestamp: string}) {
    this.listeners.forEach(listener => listener(query));
  }
};

// Define the custom type for the supabase client to include both RPC functions
export type CustomSupabaseClient = ReturnType<typeof createClient<Database>> & {
  rpc(
    fn: "increment" | "decrement",
    params: { row_id: string; value: number }
  ): Promise<{ data: number | null; error: Error | null }>;
};

// Create the supabase client with the extended type
export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY
) as CustomSupabaseClient;

// Create a wrapped version of the client methods that log queries
const originalFrom = supabase.from.bind(supabase);
supabase.from = function(table: string) {
  const result = originalFrom(table);
  
  // Wrap query methods to log them
  const originalSelect = result.select.bind(result);
  result.select = function(...args: any[]) {
    const selectResult = originalSelect(...args);
    queryLogEvents.emitQuery({
      sql: `SELECT * FROM ${table} ${args.length > 0 ? `WITH ARGS: ${args.join(', ')}` : ''}`,
      operation: 'SELECT',
      timestamp: new Date().toISOString()
    });
    return selectResult;
  };
  
  const originalInsert = result.insert.bind(result);
  result.insert = function(values: any, options?: any) {
    const insertResult = originalInsert(values, options);
    queryLogEvents.emitQuery({
      sql: `INSERT INTO ${table} ${JSON.stringify(values)}`,
      operation: 'INSERT',
      timestamp: new Date().toISOString()
    });
    return insertResult;
  };
  
  const originalUpdate = result.update.bind(result);
  result.update = function(values: any, options?: any) {
    const updateResult = originalUpdate(values, options);
    queryLogEvents.emitQuery({
      sql: `UPDATE ${table} SET ${JSON.stringify(values)}`,
      operation: 'UPDATE',
      timestamp: new Date().toISOString()
    });
    return updateResult;
  };
  
  const originalDelete = result.delete.bind(result);
  result.delete = function(options?: any) {
    const deleteResult = originalDelete(options);
    queryLogEvents.emitQuery({
      sql: `DELETE FROM ${table}`,
      operation: 'DELETE',
      timestamp: new Date().toISOString()
    });
    return deleteResult;
  };
  
  return result;
};

// Also wrap RPC functions to log them
const originalRpc = supabase.rpc.bind(supabase);
supabase.rpc = function(fn: any, params?: any) {
  const rpcResult = originalRpc(fn, params);
  queryLogEvents.emitQuery({
    sql: `CALL ${fn}(${params ? JSON.stringify(params) : ''})`,
    operation: 'RPC',
    timestamp: new Date().toISOString()
  });
  return rpcResult;
};
